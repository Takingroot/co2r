directive_timeline_conductor = ->
  restrict:   \E
  replace:    on
  transclude: on
  controller: ($scope)->
    $scope.slider = $!

    @register_slider = (new-slider)->
      #console.log 'adding new slider', new-slider, 'into', $scope.slider
      $scope.slider = $scope.slider.add new-slider

  template: "<div class='timeline-conductor' ng-transclude></div>"
  link: (scope, el, attrs)->

    conductor = el
    c-index   = 0
    # declare here to make available in scope
    column-count = undefined
    column-width = undefined

    attrs.$observe 'columnCount', ->
      column-count := scope.$eval attrs.columnCount
      column-width := scope.$eval attrs.columnWidth
      c-index      := 0
      scope.move-timeline c-index

    $(window).resize ->
      # we need to apply because window resizing could potentially change whether or not we need to show navigation arrows
      scope.$apply!
      auto-shift!



    #
    # actions
    #

    move-timeline = scope.move-timeline = (to-index)->
      new_index = visually-restrict-index-to-conductor restrict-index-to-bounds relative-to-absolute to-index
      #console.log 'move to index:', new_index
      c-index   = new_index
      scope.slider.css \margin-left, (position-for-index new_index or '')

      #console.log "checking if can move timeline in direction:", direction
      #console.log 'go backward', ' | x before move is: ', current_timeline_x(), ' vs after: ', new_x
      #console.log 'go forward', ' | x before move is: ', current_timeline_x(), ' vs after: ', new_x


    # TODO come up with a better function name
    auto-shift = ->

      # 'if' optimization
      # if we are at the beginning of the timeline there simply are no columns to shift over
      if not at-timeline-end!
        scope.move-timeline "+#{enough-room-for-how-many-columns!}"


    #
    # utilities
    #

    visually-restrict-index-to-conductor = (to-index)->
      if is-within-visual-bounds to-index then to-index else most-recent-index-that-can-be-seeked!


    is-within-index-range = (to-index)->
      #console.log "trying to go to:", to-index, " which must be between or equal 0-", last-index()
      last-index! >= to-index >= 0

    # the limit is the columns that conductor can fit
    # i.e. if 3, the index can never go below 3
    #console.log "trying to go to:", to-index, " which must be more than", most-recent-index-that-can-be-seeked()
    is-within-visual-bounds = (to-index)->
      to-index >= most-recent-index-that-can-be-seeked!


    # how many columns can the conductor fit?
    most-recent-index-that-can-be-seeked = ->
      # - 1 because we are result value must be accurate in terms of array-addressable (0-based)
      Math.floor(conductor.width! / column-width) - 1




    enough-room-for-how-many-columns = ->
      slider-width-on-left-side = ->
        # we need to add 1 because we're interested in the _count_ of indexes up to and including current index in order to get the full width
        (c-index+1) * column-width

      available-width = conductor.width! - slider-width-on-left-side!

      enough-room-for-coluns = if available-width > 0 then Math.floor(available-width / column-width) else 0
      #console.log 'enough room for', enough-room-for-coluns, 'column(s)'
      enough-room-for-coluns


    last-index = ->
      column-count - 1


    at-timeline-start = ->
      c-index is 0


    position-for-index = (index)->
      -1 * (last-index! - index) * column-width


    at-timeline-end = ->
      c-index is last-index() #or last_column_is_viewable()


    can_move-timeline = scope.can_move-timeline = (to-index_)->

      slider_width    = scope.slider.width!
      conductor_width = conductor.width!
      if slider_width < conductor_width
        #console.log 'cannot move because slider width (', slider_width ,') is less than containing width (', conductor_width,')  (thereofe has no need to move...everythig is visible)'
        return no

      to-index = relative-to-absolute to-index_
      #console.log 'trying to go to', to-index, index, 'in state of: current index is ', c-index, 'within a limit of 0 -', column-count-1
      to-index |> (is-within-visual-bounds and is-within-index-range)


    restrict-index-to-bounds = (index)->
      | index < 0           => 0
      | index > last-index! => last-index!
      | _                   => index


    relative-to-absolute = (direction_)->
      # passthrough because direction is absolute (1,2,3,..etc) not relative '+1', '-2', etc
      return direction_ if typeof direction_ isnt \string

      # + or -
      direction   = direction_.0
      delta-index = parseInt direction_.substring 1
      #console.log 'for', direction_, 'direction is', direction, 'delta-index is', delta-index

      switch direction
        when \- then return c-index - delta-index
        when \+ then return c-index + delta-index
        else         throw "The direction #direction is not allowed (must be '-' or '+')"
